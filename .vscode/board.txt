Сценарий 1: Пользователь (например, логист, капитан) хочет рассчитать и сохранить новый маршрут
Вход/Регистрация (через Frontend или API-клиент):
Пользователь заходит на ваш веб-сайт (или использует мобильное приложение/десктопный клиент).
Если он новый, он регистрируется (POST-запрос на /api/v1/register/, который обрабатывается UserRegistrationView и UserRegistrationSerializer в Django). Создается объект CustomUser.
Если существующий, он логинится (POST-запрос на эндпоинт входа, который выдает токен доступа, например, JWT или Django session cookie).
Создание нового маршрута (через Frontend или API-клиент):
Пользователь нажимает "Создать новый маршрут".
Ему предлагается ввести:
Название маршрута (например, "Рейс Роттердам - Гамбург - Гданьск").
Возможно, выбрать видимость (публичный/приватный).
Frontend отправляет POST-запрос на /api/v1/routes/ (обрабатывается RouteViewSet и RouteSerializer в Django).
В базе данных создается новый объект Route. Поле created_by автоматически связывается с текущим залогиненным пользователем. Поля total_distance, total_estimated_time, calculation_status пока могут быть пустыми или PENDING.
Добавление маршрутных точек (waypoints) к маршруту:
Пользователь выбирает созданный маршрут.
Ему предоставляется интерфейс для добавления портов в качестве маршрутных точек. Он может:
Искать порты по названию (GET-запрос на /api/v1/ports/?name=...).
Выбирать из списка всех портов (GET-запрос на /api/v1/ports/).
Для каждой выбранной точки он указывает ее порядок в маршруте.
Frontend отправляет POST-запросы на /api/v1/routes/{route_id}/waypoints/ (если у вас такой вложенный эндпоинт) или на /api/v1/route_waypoints/ (передавая route_id и port_id). Это обрабатывается RouteWaypointViewSet и RouteWaypointSerializer.
В базе данных создаются объекты RouteWaypoint, связанные с Route и Port. Поля ETA и ETD пока пустые.
Инициирование расчета маршрута:
Когда все маршрутные точки добавлены, пользователь нажимает кнопку "Рассчитать маршрут".
Frontend отправляет POST-запрос на специальный эндпоинт, например, /api/v1/routes/{route_id}/calculate/ (этот эндпоинт вам нужно будет создать в apps/routes/views.py).
Действия в Django (apps/routes/views.py):
Получает route_id.
Находит соответствующий объект Route и его RouteWaypoint'ы.
Формирует сообщение для Kafka. Сообщение будет содержать:
route_id (чтобы воркер знал, какой маршрут обновлять).
Список ID портов в правильном порядке из RouteWaypoint.
Возможно, ID судна (vessel_id), если расчет зависит от скорости конкретного судна, и пользователь его выбрал.
Использует kafka_producer.send_route_calculation_task() для отправки этого сообщения в топик Kafka (например, route_calculation_tasks).
Обновляет статус объекта Route в базе данных на PROCESSING (или CALCULATION_QUEUED).
Возвращает ответ пользователю, например, "Запрос на расчет маршрута принят, ожидайте результатов."
Обработка задачи FastAPI-воркером (RoutesCalculatorService):
Kafka-консьюмер в main.py воркера получает сообщение из топика route_calculation_tasks.
Извлекает route_id, список ID портов.
Вызывает algorithm.a_star_search(), передавая ему ID начального и конечного портов (или последовательно для пар waypoints).
a_star_search использует db_interface.py для загрузки из БД информации о портах (координаты) и сегментах (расстояния).
Алгоритм рассчитывает кратчайший путь (последовательность объектов Port или их данных) и общую дистанцию.
Воркер обновляет базу данных:
Находит объект Route по route_id.
Записывает в него total_distance.
Обновляет статус на COMPLETED (или FAILED, если путь не найден).
Самое важное (и сложное): На основе полученного пути, total_distance и скорости судна (если она передана или берется из модели Vessel), воркер должен рассчитать ETA (Estimated Time of Arrival) и ETD (Estimated Time of Departure) для каждого RouteWaypoint этого маршрута. Это потребует итерации по сегментам пути, расчета времени на каждый сегмент и кумулятивного сложения времени.
Все изменения сохраняются в БД.
Отображение результатов пользователю (через Frontend или API-клиент):
Пользователь может периодически проверять статус маршрута (GET-запрос на /api/v1/routes/{route_id}/).
Когда статус станет COMPLETED, frontend запросит обновленные данные маршрута и его маршрутных точек (включая рассчитанные ETA/ETD).
Маршрут с рассчитанными временами и расстоянием отображается пользователю, возможно, на карте.
Сценарий 2: Пользователь просматривает существующие маршруты
Пользователь заходит в раздел "Мои маршруты" или "Все публичные маршруты".
Frontend делает GET-запрос на /api/v1/routes/ (возможно, с фильтрами по created_by=current_user_id или is_public=true).
Django возвращает список маршрутов. Для каждого маршрута могут сразу подгружаться его маршрутные точки с ETA/ETD (если сериализатор настроен на вложенность или делаются отдельные запросы).
Пользователь выбирает маршрут для просмотра деталей.
Сценарий 3: Администратор управляет данными
Администратор заходит в Django Admin (/admin/).
Он может:
Просматривать, добавлять, редактировать, удалять Port.
Просматривать, добавлять, редактировать, удалять Segment (ребра графа). Это важно для поддержания актуальности данных для A*.
Просматривать, добавлять, редактировать, удалять VesselType и Vessel.
Просматривать Route и RouteWaypoint, возможно, вручную запускать пересчет или изменять статусы.
Управлять пользователями (CustomUser), их ролями.
Основной функционал для пользователя (не администратора):
Просмотр портов: Поиск, фильтрация.
Создание маршрутов: Задание имени, начальной/конечной/промежуточных точек.
Расчет маршрутов: Инициирование асинхронного расчета.
Просмотр рассчитанных маршрутов: Отображение пути, общей дистанции, ETA/ETD для каждой точки.
Редактирование своих маршрутов.
Удаление своих маршрутов.
(Опционально) Привязка судов к маршрутам: Если вы реализуете модель VesselRouteAssignment, пользователь сможет назначать конкретное судно на выполнение маршрута, и тогда скорость этого судна будет использоваться для более точного расчета ETA/ETD.
(Опционально) Получение уведомлений: Например, когда расчет маршрута завершен или если ETA/ETD изменились.
Ключевые взаимодействия:
Frontend/API-клиент <-> Django API: Для всех CRUD-операций с данными, аутентификации, инициирования расчетов.
Django -> Kafka: Отправка задач на расчет.
Kafka -> FastAPI-воркер: Получение задач на расчет.
FastAPI-воркер <-> PostgreSQL: Чтение данных графа (порты, сегменты) и запись результатов расчета (обновление маршрутов, ETA/ETD).
Django <-> PostgreSQL: Стандартная работа Django ORM.
Это общая картина. Детали будут зависеть от того, насколько сложным вы хотите сделать интерфейс и какие именно функции будут наиболее востребованы вашими пользователями. Начните с базового сценария создания и расчета маршрута, а затем расширяйте функционал.
Start typing a prompt

Run
